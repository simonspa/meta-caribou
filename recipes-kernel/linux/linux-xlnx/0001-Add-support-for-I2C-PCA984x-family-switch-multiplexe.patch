From 21de2577a625d713991e462ad033389f13693f89 Mon Sep 17 00:00:00 2001
From: Adrian Fiergolski <adrian.fiergolski@cern.ch>
Date: Fri, 24 Nov 2017 17:16:20 +0100
Subject: [PATCH] Add support for I2C PCA984x family (switch/multiplexers).

Signed-off-by: Adrian Fiergolski <adrian.fiergolski@cern.ch>
---
 .../{i2c-mux-pca954x.txt => i2c-mux-pca9x4x.txt}   |   3 +-
 drivers/i2c/muxes/Makefile                         |   2 +-
 drivers/i2c/muxes/i2c-mux-pca9541.c                |   4 +-
 .../muxes/{i2c-mux-pca954x.c => i2c-mux-pca9x4x.c} | 297 ++++++++++++++++-----
 include/linux/i2c/{pca954x.h => pca9x4x.h}         |  13 +-
 5 files changed, 236 insertions(+), 83 deletions(-)
 rename Documentation/devicetree/bindings/i2c/{i2c-mux-pca954x.txt => i2c-mux-pca9x4x.txt} (90%)
 rename drivers/i2c/muxes/{i2c-mux-pca954x.c => i2c-mux-pca9x4x.c} (56%)
 rename include/linux/i2c/{pca954x.h => pca9x4x.h} (82%)

diff --git a/Documentation/devicetree/bindings/i2c/i2c-mux-pca954x.txt b/Documentation/devicetree/bindings/i2c/i2c-mux-pca9x4x.txt
similarity index 90%
rename from Documentation/devicetree/bindings/i2c/i2c-mux-pca954x.txt
rename to Documentation/devicetree/bindings/i2c/i2c-mux-pca9x4x.txt
index cf53d5fba20a..e5273de815f4 100644
--- a/Documentation/devicetree/bindings/i2c/i2c-mux-pca954x.txt
+++ b/Documentation/devicetree/bindings/i2c/i2c-mux-pca9x4x.txt
@@ -4,7 +4,8 @@ Required Properties:
 
   - compatible: Must contain one of the following.
     "nxp,pca9540", "nxp,pca9542", "nxp,pca9543", "nxp,pca9544",
-    "nxp,pca9545", "nxp,pca9546", "nxp,pca9547", "nxp,pca9548"
+    "nxp,pca9545", "nxp,pca9546", "nxp,pca9547", "nxp,pca9548",
+    "nxp,PCA9846", "nxp,PCA9847", "nxp,PCA9848", "nxp,PCA9849"
 
   - reg: The I2C address of the device.
 
diff --git a/drivers/i2c/muxes/Makefile b/drivers/i2c/muxes/Makefile
index 7c267c29b191..1662e5ebf1d8 100644
--- a/drivers/i2c/muxes/Makefile
+++ b/drivers/i2c/muxes/Makefile
@@ -7,7 +7,7 @@ obj-$(CONFIG_I2C_DEMUX_PINCTRL)		+= i2c-demux-pinctrl.o
 
 obj-$(CONFIG_I2C_MUX_GPIO)	+= i2c-mux-gpio.o
 obj-$(CONFIG_I2C_MUX_PCA9541)	+= i2c-mux-pca9541.o
-obj-$(CONFIG_I2C_MUX_PCA954x)	+= i2c-mux-pca954x.o
+obj-$(CONFIG_I2C_MUX_PCA954x)	+= i2c-mux-pca9x4x.o
 obj-$(CONFIG_I2C_MUX_PINCTRL)	+= i2c-mux-pinctrl.o
 obj-$(CONFIG_I2C_MUX_REG)	+= i2c-mux-reg.o
 
diff --git a/drivers/i2c/muxes/i2c-mux-pca9541.c b/drivers/i2c/muxes/i2c-mux-pca9541.c
index 4ea7e691afc7..31fb32256ac6 100644
--- a/drivers/i2c/muxes/i2c-mux-pca9541.c
+++ b/drivers/i2c/muxes/i2c-mux-pca9541.c
@@ -24,7 +24,7 @@
 #include <linux/i2c.h>
 #include <linux/i2c-mux.h>
 
-#include <linux/i2c/pca954x.h>
+#include <linux/i2c/pca9x4x.h>
 
 /*
  * The PCA9541 is a bus master selector. It supports two I2C masters connected
@@ -334,7 +334,7 @@ static int pca9541_probe(struct i2c_client *client,
 			 const struct i2c_device_id *id)
 {
 	struct i2c_adapter *adap = client->adapter;
-	struct pca954x_platform_data *pdata = dev_get_platdata(&client->dev);
+	struct pca9x4x_platform_data *pdata = dev_get_platdata(&client->dev);
 	struct i2c_mux_core *muxc;
 	struct pca9541 *data;
 	int force;
diff --git a/drivers/i2c/muxes/i2c-mux-pca954x.c b/drivers/i2c/muxes/i2c-mux-pca9x4x.c
similarity index 56%
rename from drivers/i2c/muxes/i2c-mux-pca954x.c
rename to drivers/i2c/muxes/i2c-mux-pca9x4x.c
index 4fe44e697604..49405c30dc2a 100644
--- a/drivers/i2c/muxes/i2c-mux-pca954x.c
+++ b/drivers/i2c/muxes/i2c-mux-pca9x4x.c
@@ -1,14 +1,16 @@
 /*
  * I2C multiplexer
  *
+ * Copyright (c) 2017 Adrian Fiergolski <Adrian.Fiergolski@cern.ch>
  * Copyright (c) 2008-2009 Rodolfo Giometti <giometti@linux.it>
  * Copyright (c) 2008-2009 Eurotech S.p.A. <info@eurotech.it>
  *
- * This module supports the PCA954x series of I2C multiplexer/switch chips
+ * This module supports the Pca9x4x series of I2C multiplexer/switch chips
  * made by Philips Semiconductors.
  * This includes the:
  *	 PCA9540, PCA9542, PCA9543, PCA9544, PCA9545, PCA9546, PCA9547
  *	 and PCA9548.
+ *       PCA9846, PCA9847, PCA9848 and PCA9849
  *
  * These chips are all controlled via the I2C bus itself, and all have a
  * single 8-bit register. The upstream "parent" bus fans out to two,
@@ -39,7 +41,7 @@
 #include <linux/gpio/consumer.h>
 #include <linux/i2c.h>
 #include <linux/i2c-mux.h>
-#include <linux/i2c/pca954x.h>
+#include <linux/i2c/pca9x4x.h>
 #include <linux/interrupt.h>
 #include <linux/irq.h>
 #include <linux/module.h>
@@ -50,10 +52,16 @@
 #include <linux/slab.h>
 #include <linux/spinlock.h>
 
-#define PCA954X_MAX_NCHANS 8
+#define PCA9X4X_MAX_NCHANS 8
 
 #define PCA954X_IRQ_OFFSET 4
 
+//PCA984x family I2C other addresses
+#define GENERAL_CALL  0x00
+#define SOFTWARE_RESET 0x06
+#define DEVICE_ID_ADDRESS 0x7C
+#define NXP_ID 0x00
+
 enum pca_type {
 	pca_9540,
 	pca_9542,
@@ -63,6 +71,12 @@ enum pca_type {
 	pca_9546,
 	pca_9547,
 	pca_9548,
+
+	pca_9846,
+	pca_9847,
+	pca_9848,
+	pca_9849,
+	
 };
 
 struct chip_desc {
@@ -70,12 +84,13 @@ struct chip_desc {
 	u8 enable;	/* used for muxes only */
 	u8 has_irq;
 	enum muxtype {
-		pca954x_ismux = 0,
-		pca954x_isswi
+		pca9x4x_ismux = 0,
+		pca9x4x_isswi
 	} muxtype;
+        u16 deviceID; //used by PCA984x family only
 };
 
-struct pca954x {
+struct pca9x4x {
 	const struct chip_desc *chip;
 
 	u8 last_chan;		/* last register value */
@@ -87,51 +102,79 @@ struct pca954x {
 	raw_spinlock_t lock;
 };
 
-/* Provide specs for the PCA954x types we know about */
+/* Provide specs for the PCA9x4x types we know about */
 static const struct chip_desc chips[] = {
+        //954x family
 	[pca_9540] = {
 		.nchans = 2,
 		.enable = 0x4,
-		.muxtype = pca954x_ismux,
+		.muxtype = pca9x4x_ismux,
 	},
 	[pca_9542] = {
 		.nchans = 2,
 		.enable = 0x4,
 		.has_irq = 1,
-		.muxtype = pca954x_ismux,
+		.muxtype = pca9x4x_ismux,
 	},
 	[pca_9543] = {
 		.nchans = 2,
 		.has_irq = 1,
-		.muxtype = pca954x_isswi,
+		.muxtype = pca9x4x_isswi,
 	},
 	[pca_9544] = {
 		.nchans = 4,
 		.enable = 0x4,
 		.has_irq = 1,
-		.muxtype = pca954x_ismux,
+		.muxtype = pca9x4x_ismux,
 	},
 	[pca_9545] = {
 		.nchans = 4,
 		.has_irq = 1,
-		.muxtype = pca954x_isswi,
+		.muxtype = pca9x4x_isswi,
 	},
 	[pca_9546] = {
 		.nchans = 4,
-		.muxtype = pca954x_isswi,
+		.muxtype = pca9x4x_isswi,
 	},
 	[pca_9547] = {
 		.nchans = 8,
 		.enable = 0x8,
-		.muxtype = pca954x_ismux,
+		.muxtype = pca9x4x_ismux,
 	},
 	[pca_9548] = {
 		.nchans = 8,
-		.muxtype = pca954x_isswi,
+		.muxtype = pca9x4x_isswi,
+	},
+
+	//984x family
+	[pca_9846] = {
+		.nchans = 4,
+		.muxtype = pca9x4x_isswi,
+		.deviceID = 0x10B,
+	},
+	
+	[pca_9847] = {
+		.nchans = 8,
+		.muxtype = pca9x4x_ismux,
+		.deviceID = 0x108,
 	},
+
+	[pca_9848] = {
+		.nchans = 8,
+		.muxtype = pca9x4x_isswi,
+		.deviceID = 0x10A,
+ 	},
+
+	[pca_9849] = {
+		.nchans = 4,
+		.muxtype = pca9x4x_ismux,
+		.deviceID = 0x109,
+	},	
+	
 };
 
-static const struct i2c_device_id pca954x_id[] = {
+static const struct i2c_device_id pca9x4x_id[] = {
+        //954x family
 	{ "pca9540", pca_9540 },
 	{ "pca9542", pca_9542 },
 	{ "pca9543", pca_9543 },
@@ -140,12 +183,20 @@ static const struct i2c_device_id pca954x_id[] = {
 	{ "pca9546", pca_9546 },
 	{ "pca9547", pca_9547 },
 	{ "pca9548", pca_9548 },
+
+	//984x family	
+	{ "pca9846", pca_9846 },
+	{ "pca9847", pca_9847 },
+	{ "pca9848", pca_9848 },
+	{ "pca9849", pca_9849 },
+	
 	{ }
 };
-MODULE_DEVICE_TABLE(i2c, pca954x_id);
+MODULE_DEVICE_TABLE(i2c, pca9x4x_id);
 
 #ifdef CONFIG_OF
-static const struct of_device_id pca954x_of_match[] = {
+static const struct of_device_id pca9x4x_of_match[] = {
+        //954x family
 	{ .compatible = "nxp,pca9540", .data = &chips[pca_9540] },
 	{ .compatible = "nxp,pca9542", .data = &chips[pca_9542] },
 	{ .compatible = "nxp,pca9543", .data = &chips[pca_9543] },
@@ -154,6 +205,14 @@ static const struct of_device_id pca954x_of_match[] = {
 	{ .compatible = "nxp,pca9546", .data = &chips[pca_9546] },
 	{ .compatible = "nxp,pca9547", .data = &chips[pca_9547] },
 	{ .compatible = "nxp,pca9548", .data = &chips[pca_9548] },
+
+
+	//984x family	
+	{ .compatible = "nxp,pca9846", .data = &chips[pca_9846] },
+	{ .compatible = "nxp,pca9847", .data = &chips[pca_9847] },
+	{ .compatible = "nxp,pca9848", .data = &chips[pca_9848] },
+	{ .compatible = "nxp,pca9849", .data = &chips[pca_9849] },
+	
 	{}
 };
 MODULE_DEVICE_TABLE(of, pca954x_of_match);
@@ -161,7 +220,7 @@ MODULE_DEVICE_TABLE(of, pca954x_of_match);
 
 /* Write to mux register. Don't use i2c_transfer()/i2c_smbus_xfer()
    for this as they will try to lock adapter a second time */
-static int pca954x_reg_write(struct i2c_adapter *adap,
+static int pca9x4x_reg_write(struct i2c_adapter *adap,
 			     struct i2c_client *client, u8 val)
 {
 	int ret = -ENODEV;
@@ -190,32 +249,32 @@ static int pca954x_reg_write(struct i2c_adapter *adap,
 	return ret;
 }
 
-static int pca954x_select_chan(struct i2c_mux_core *muxc, u32 chan)
+static int pca9x4x_select_chan(struct i2c_mux_core *muxc, u32 chan)
 {
-	struct pca954x *data = i2c_mux_priv(muxc);
+	struct pca9x4x *data = i2c_mux_priv(muxc);
 	struct i2c_client *client = data->client;
 	const struct chip_desc *chip = data->chip;
 	u8 regval;
 	int ret = 0;
 
 	/* we make switches look like muxes, not sure how to be smarter */
-	if (chip->muxtype == pca954x_ismux)
+	if (chip->muxtype == pca9x4x_ismux)
 		regval = chan | chip->enable;
 	else
 		regval = 1 << chan;
 
 	/* Only select the channel if its different from the last channel */
 	if (data->last_chan != regval) {
-		ret = pca954x_reg_write(muxc->parent, client, regval);
+		ret = pca9x4x_reg_write(muxc->parent, client, regval);
 		data->last_chan = ret < 0 ? 0 : regval;
 	}
 
 	return ret;
 }
 
-static int pca954x_deselect_mux(struct i2c_mux_core *muxc, u32 chan)
+static int pca9x4x_deselect_mux(struct i2c_mux_core *muxc, u32 chan)
 {
-	struct pca954x *data = i2c_mux_priv(muxc);
+	struct pca9x4x *data = i2c_mux_priv(muxc);
 	struct i2c_client *client = data->client;
 
 	if (!(data->deselect & (1 << chan)))
@@ -223,12 +282,12 @@ static int pca954x_deselect_mux(struct i2c_mux_core *muxc, u32 chan)
 
 	/* Deselect active channel */
 	data->last_chan = 0;
-	return pca954x_reg_write(muxc->parent, client, data->last_chan);
+	return pca9x4x_reg_write(muxc->parent, client, data->last_chan);
 }
 
-static irqreturn_t pca954x_irq_handler(int irq, void *dev_id)
+static irqreturn_t pca9x4x_irq_handler(int irq, void *dev_id)
 {
-	struct pca954x *data = dev_id;
+	struct pca9x4x *data = dev_id;
 	unsigned int child_irq;
 	int ret, i, handled = 0;
 
@@ -246,9 +305,9 @@ static irqreturn_t pca954x_irq_handler(int irq, void *dev_id)
 	return handled ? IRQ_HANDLED : IRQ_NONE;
 }
 
-static void pca954x_irq_mask(struct irq_data *idata)
+static void pca9x4x_irq_mask(struct irq_data *idata)
 {
-	struct pca954x *data = irq_data_get_irq_chip_data(idata);
+	struct pca9x4x *data = irq_data_get_irq_chip_data(idata);
 	unsigned int pos = idata->hwirq;
 	unsigned long flags;
 
@@ -261,9 +320,9 @@ static void pca954x_irq_mask(struct irq_data *idata)
 	raw_spin_unlock_irqrestore(&data->lock, flags);
 }
 
-static void pca954x_irq_unmask(struct irq_data *idata)
+static void pca9x4x_irq_unmask(struct irq_data *idata)
 {
-	struct pca954x *data = irq_data_get_irq_chip_data(idata);
+	struct pca9x4x *data = irq_data_get_irq_chip_data(idata);
 	unsigned int pos = idata->hwirq;
 	unsigned long flags;
 
@@ -276,23 +335,23 @@ static void pca954x_irq_unmask(struct irq_data *idata)
 	raw_spin_unlock_irqrestore(&data->lock, flags);
 }
 
-static int pca954x_irq_set_type(struct irq_data *idata, unsigned int type)
+static int pca9x4x_irq_set_type(struct irq_data *idata, unsigned int type)
 {
 	if ((type & IRQ_TYPE_SENSE_MASK) != IRQ_TYPE_LEVEL_LOW)
 		return -EINVAL;
 	return 0;
 }
 
-static struct irq_chip pca954x_irq_chip = {
-	.name = "i2c-mux-pca954x",
-	.irq_mask = pca954x_irq_mask,
-	.irq_unmask = pca954x_irq_unmask,
-	.irq_set_type = pca954x_irq_set_type,
+static struct irq_chip pca9x4x_irq_chip = {
+	.name = "i2c-mux-pca9x4x",
+	.irq_mask = pca9x4x_irq_mask,
+	.irq_unmask = pca9x4x_irq_unmask,
+	.irq_set_type = pca9x4x_irq_set_type,
 };
 
-static int pca954x_irq_setup(struct i2c_mux_core *muxc)
+static int pca9x4x_irq_setup(struct i2c_mux_core *muxc)
 {
-	struct pca954x *data = i2c_mux_priv(muxc);
+	struct pca9x4x *data = i2c_mux_priv(muxc);
 	struct i2c_client *client = data->client;
 	int c, err, irq;
 
@@ -310,14 +369,14 @@ static int pca954x_irq_setup(struct i2c_mux_core *muxc)
 	for (c = 0; c < data->chip->nchans; c++) {
 		irq = irq_create_mapping(data->irq, c);
 		irq_set_chip_data(irq, data);
-		irq_set_chip_and_handler(irq, &pca954x_irq_chip,
+		irq_set_chip_and_handler(irq, &pca9x4x_irq_chip,
 			handle_simple_irq);
 	}
 
 	err = devm_request_threaded_irq(&client->dev, data->client->irq, NULL,
-					pca954x_irq_handler,
+					pca9x4x_irq_handler,
 					IRQF_ONESHOT | IRQF_SHARED,
-					"pca954x", data);
+					"pca9x4x", data);
 	if (err)
 		goto err_req_irq;
 
@@ -334,20 +393,97 @@ static int pca954x_irq_setup(struct i2c_mux_core *muxc)
 	return err;
 }
 
+/*
+ * Part of probe function specific for pca954x family
+ */
+inline int pca954x_probe(struct i2c_client *client,
+			 const struct i2c_device_id *id){
+  struct pca9x4x *data =  i2c_get_clientdata(client);
+
+  /* Write the mux register at addr to verify
+   * that the mux is in fact present. This also
+   * initializes the mux to disconnected state.
+   */
+  if (i2c_smbus_write_byte(client, 0) < 0) {
+    return -ENODEV;
+  }
+
+  return 0;
+}
+
+/*
+ * Part of probe function specific for pca984x family
+ */
+inline int pca984x_probe(struct i2c_client *client,
+			 const struct i2c_device_id *id){
+
+  struct i2c_adapter *adap = to_i2c_adapter(client->dev.parent);
+  struct pca9x4x *data =  i2c_get_clientdata(client);
+  union i2c_smbus_data device_id_raw;  
+  u16 manufacturer_id; //12 bits
+  u16 device_id; //9 bits
+  u16 i; //iterator through chips table
+  
+  if ( !i2c_check_functionality(adap, I2C_FUNC_SMBUS_WRITE_BYTE_DATA) ){
+    dev_warn(&client->dev, "PCA9846 family: I2c adapter doesn't support I2C_FUNC_SMBUS_WRITE_BYTE_DATA");
+    return -ENODEV;
+  }
+
+  if ( !i2c_check_functionality(adap, I2C_FUNC_SMBUS_READ_I2C_BLOCK) ){
+    dev_warn(&client->dev, "PCA9846 family: I2c adapter doesn't support  I2C_FUNC_SMBUS_READ_I2C_BLOCK");
+    return -ENODEV;
+  }
+  
+  //
+  //Software reset
+  //
+  if ( i2c_smbus_xfer(client->adapter, GENERAL_CALL, client->flags,
+		      I2C_SMBUS_WRITE,  SOFTWARE_RESET, I2C_SMBUS_BYTE, NULL)  < 0 ) {
+    dev_warn(&client->dev, "PCA9846 family: Sofrware reset failed\n");
+    return -ENODEV;
+  }
+
+  //
+  //Get device ID
+  //
+  device_id_raw.block[0] = 3;  //read 3 bytes
+  if( i2c_smbus_xfer(client->adapter, DEVICE_ID_ADDRESS, client->flags,
+		     I2C_SMBUS_READ,  client->addr <<1,
+		     I2C_SMBUS_I2C_BLOCK_DATA, &device_id_raw ) ){
+    dev_warn(&client->dev, "PCA9846 family: Get device ID failed\n");
+    return -ENODEV;
+  }
+
+  //Device ID contains only 3 bytes
+  if( device_id_raw.block[0] != 3 ){
+    dev_warn(&client->dev, "PCA9846 family: Get device ID failed\n");
+    return -ENODEV;
+  }
+
+  //Check manufacturer ID (12 bits)
+  manufacturer_id = ( (u16) device_id_raw.block[1] << 4) | (device_id_raw.block[2] >> 4);
+  if( manufacturer_id != NXP_ID){
+    dev_warn(&client->dev, "PCA9846 family: Manufacturer ID does not match NXP\n");
+    return -ENODEV;
+  }
+
+  return 0;
+}
+
 /*
  * I2C init/probing/exit functions
  */
-static int pca954x_probe(struct i2c_client *client,
+static int pca9x4x_probe(struct i2c_client *client,
 			 const struct i2c_device_id *id)
 {
 	struct i2c_adapter *adap = to_i2c_adapter(client->dev.parent);
-	struct pca954x_platform_data *pdata = dev_get_platdata(&client->dev);
+	struct pca9x4x_platform_data *pdata = dev_get_platdata(&client->dev);
 	struct device_node *of_node = client->dev.of_node;
 	bool idle_disconnect_dt;
 	struct gpio_desc *gpio;
 	int num, force, class;
 	struct i2c_mux_core *muxc;
-	struct pca954x *data;
+	struct pca9x4x *data;
 	const struct of_device_id *match;
 	int ret;
 
@@ -355,8 +491,8 @@ static int pca954x_probe(struct i2c_client *client,
 		return -ENODEV;
 
 	muxc = i2c_mux_alloc(adap, &client->dev,
-			     PCA954X_MAX_NCHANS, sizeof(*data), 0,
-			     pca954x_select_chan, pca954x_deselect_mux);
+			     PCA9X4X_MAX_NCHANS, sizeof(*data), 0,
+			     pca9x4x_select_chan, pca9x4x_deselect_mux);
 	if (!muxc)
 		return -ENOMEM;
 	data = i2c_mux_priv(muxc);
@@ -369,16 +505,31 @@ static int pca954x_probe(struct i2c_client *client,
 	if (IS_ERR(gpio))
 		return PTR_ERR(gpio);
 
-	/* Write the mux register at addr to verify
-	 * that the mux is in fact present. This also
-	 * initializes the mux to disconnected state.
-	 */
-	if (i2c_smbus_write_byte(client, 0) < 0) {
-		dev_warn(&client->dev, "probe failed\n");
-		return -ENODEV;
+        switch( id->driver_data ) {
+	case pca_9540 :
+	case pca_9542 :
+	case pca_9543 :
+	case pca_9544 :
+	case pca_9545 :
+	case pca_9546 :
+	case pca_9547 :
+	case pca_9548 :
+	  ret = pca954x_probe(client, id);
+	  break;
+	case pca_9846 :
+	case pca_9847 :
+	case pca_9848 :
+	case pca_9849 :
+	  ret = pca984x_probe(client, id);
+	  break;
 	}
 
-	match = of_match_device(of_match_ptr(pca954x_of_match), &client->dev);
+	if(ret < 0) {
+	  dev_warn(&client->dev, "probe failed\n");
+	  return -ENODEV;
+	}	
+	
+	match = of_match_device(of_match_ptr(pca9x4x_of_match), &client->dev);
 	if (match)
 		data->chip = of_device_get_match_data(&client->dev);
 	else
@@ -389,7 +540,7 @@ static int pca954x_probe(struct i2c_client *client,
 	idle_disconnect_dt = of_node &&
 		of_property_read_bool(of_node, "i2c-mux-idle-disconnect");
 
-	ret = pca954x_irq_setup(muxc);
+	ret = pca9x4x_irq_setup(muxc);
 	if (ret)
 		goto fail_del_adapters;
 
@@ -424,7 +575,7 @@ static int pca954x_probe(struct i2c_client *client,
 
 	dev_info(&client->dev,
 		 "registered %d multiplexed busses for I2C %s %s\n",
-		 num, data->chip->muxtype == pca954x_ismux
+		 num, data->chip->muxtype == pca9x4x_ismux
 				? "mux" : "switch", client->name);
 
 	return 0;
@@ -434,10 +585,10 @@ static int pca954x_probe(struct i2c_client *client,
 	return ret;
 }
 
-static int pca954x_remove(struct i2c_client *client)
+static int pca9x4x_remove(struct i2c_client *client)
 {
 	struct i2c_mux_core *muxc = i2c_get_clientdata(client);
-	struct pca954x *data = i2c_mux_priv(muxc);
+	struct pca9x4x *data = i2c_mux_priv(muxc);
 	int c, irq;
 
 	if (data->irq) {
@@ -453,32 +604,32 @@ static int pca954x_remove(struct i2c_client *client)
 }
 
 #ifdef CONFIG_PM_SLEEP
-static int pca954x_resume(struct device *dev)
+static int pca9x4x_resume(struct device *dev)
 {
 	struct i2c_client *client = to_i2c_client(dev);
 	struct i2c_mux_core *muxc = i2c_get_clientdata(client);
-	struct pca954x *data = i2c_mux_priv(muxc);
+	struct pca9x4x *data = i2c_mux_priv(muxc);
 
 	data->last_chan = 0;
 	return i2c_smbus_write_byte(client, 0);
 }
 #endif
 
-static SIMPLE_DEV_PM_OPS(pca954x_pm, NULL, pca954x_resume);
+static SIMPLE_DEV_PM_OPS(pca9x4x_pm, NULL, pca9x4x_resume);
 
-static struct i2c_driver pca954x_driver = {
+static struct i2c_driver pca9x4x_driver = {
 	.driver		= {
-		.name	= "pca954x",
-		.pm	= &pca954x_pm,
-		.of_match_table = of_match_ptr(pca954x_of_match),
+		.name	= "pca9x4x",
+		.pm	= &pca9x4x_pm,
+		.of_match_table = of_match_ptr(pca9x4x_of_match),
 	},
-	.probe		= pca954x_probe,
-	.remove		= pca954x_remove,
-	.id_table	= pca954x_id,
+	.probe		= pca9x4x_probe,
+	.remove		= pca9x4x_remove,
+	.id_table	= pca9x4x_id,
 };
 
-module_i2c_driver(pca954x_driver);
+module_i2c_driver(pca9x4x_driver);
 
-MODULE_AUTHOR("Rodolfo Giometti <giometti@linux.it>");
-MODULE_DESCRIPTION("PCA954x I2C mux/switch driver");
+MODULE_AUTHOR("Rodolfo Giometti <giometti@linux.it>, Adrian Fiergolski <Adrian.Fiergolski@cern.ch>");
+MODULE_DESCRIPTION("PCA9x4x I2C mux/switch driver");
 MODULE_LICENSE("GPL v2");
diff --git a/include/linux/i2c/pca954x.h b/include/linux/i2c/pca9x4x.h
similarity index 82%
rename from include/linux/i2c/pca954x.h
rename to include/linux/i2c/pca9x4x.h
index 1712677d5904..2aa3f947bad4 100644
--- a/include/linux/i2c/pca954x.h
+++ b/include/linux/i2c/pca9x4x.h
@@ -2,6 +2,7 @@
  *
  * pca954x.h - I2C multiplexer/switch support
  *
+ * Copyright (c) 2017 Adrian Fiergolski <Adrian.Fiergolski@cern.ch>
  * Copyright (c) 2008-2009 Rodolfo Giometti <giometti@linux.it>
  * Copyright (c) 2008-2009 Eurotech S.p.A. <info@eurotech.it>
  * Michael Lawnick <michael.lawnick.ext@nsn.com>
@@ -22,10 +23,10 @@
  */
 
 
-#ifndef _LINUX_I2C_PCA954X_H
-#define _LINUX_I2C_PCA954X_H
+#ifndef _LINUX_I2C_PCA9X4X_H
+#define _LINUX_I2C_PCA9X4X_H
 
-/* Platform data for the PCA954x I2C multiplexers */
+/* Platform data for the PCA9X4x I2C multiplexers */
 
 /* Per channel initialisation data:
  * @adap_id: bus number for the adapter. 0 = don't care
@@ -33,15 +34,15 @@
  *                    of this channel after transaction.
  *
  */
-struct pca954x_platform_mode {
+struct pca9x4x_platform_mode {
 	int		adap_id;
 	unsigned int	deselect_on_exit:1;
 	unsigned int	class;
 };
 
 /* Per mux/switch data, used with i2c_register_board_info */
-struct pca954x_platform_data {
-	struct pca954x_platform_mode *modes;
+struct pca9x4x_platform_data {
+	struct pca9x4x_platform_mode *modes;
 	int num_modes;
 };
 
-- 
2.14.1

