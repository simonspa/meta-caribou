From 22fcba44b3e3e34bb350ba9f0f138a8d54d284e0 Mon Sep 17 00:00:00 2001
From: Adrian Fiergolski <adrian.fiergolski@cern.ch>
Date: Tue, 17 Jan 2017 19:18:25 +0100
Subject: [PATCH 2/2] Add support for I2C PCA984x family (switch/multiplexers).

Signed-off-by: Adrian Fiergolski <adrian.fiergolski@cern.ch>
---
 .../{i2c-mux-pca954x.txt => i2c-mux-pca9x4x.txt}   |   3 +-
 drivers/i2c/muxes/Makefile                         |   2 +-
 drivers/i2c/muxes/i2c-mux-pca9541.c                |   4 +-
 drivers/i2c/muxes/i2c-mux-pca954x.c                | 313 --------------
 drivers/i2c/muxes/i2c-mux-pca9x4x.c                | 479 +++++++++++++++++++++
 include/linux/i2c/{pca954x.h => pca9x4x.h}         |  13 +-
 6 files changed, 491 insertions(+), 323 deletions(-)
 rename Documentation/devicetree/bindings/i2c/{i2c-mux-pca954x.txt => i2c-mux-pca9x4x.txt} (90%)
 delete mode 100644 drivers/i2c/muxes/i2c-mux-pca954x.c
 create mode 100644 drivers/i2c/muxes/i2c-mux-pca9x4x.c
 rename include/linux/i2c/{pca954x.h => pca9x4x.h} (82%)

diff --git a/Documentation/devicetree/bindings/i2c/i2c-mux-pca954x.txt b/Documentation/devicetree/bindings/i2c/i2c-mux-pca9x4x.txt
similarity index 90%
rename from Documentation/devicetree/bindings/i2c/i2c-mux-pca954x.txt
rename to Documentation/devicetree/bindings/i2c/i2c-mux-pca9x4x.txt
index cf53d5f..e5273de 100644
--- a/Documentation/devicetree/bindings/i2c/i2c-mux-pca954x.txt
+++ b/Documentation/devicetree/bindings/i2c/i2c-mux-pca9x4x.txt
@@ -4,7 +4,8 @@ Required Properties:
 
   - compatible: Must contain one of the following.
     "nxp,pca9540", "nxp,pca9542", "nxp,pca9543", "nxp,pca9544",
-    "nxp,pca9545", "nxp,pca9546", "nxp,pca9547", "nxp,pca9548"
+    "nxp,pca9545", "nxp,pca9546", "nxp,pca9547", "nxp,pca9548",
+    "nxp,PCA9846", "nxp,PCA9847", "nxp,PCA9848", "nxp,PCA9849"
 
   - reg: The I2C address of the device.
 
diff --git a/drivers/i2c/muxes/Makefile b/drivers/i2c/muxes/Makefile
index 7c267c2..1662e5e 100644
--- a/drivers/i2c/muxes/Makefile
+++ b/drivers/i2c/muxes/Makefile
@@ -7,7 +7,7 @@ obj-$(CONFIG_I2C_DEMUX_PINCTRL)		+= i2c-demux-pinctrl.o
 
 obj-$(CONFIG_I2C_MUX_GPIO)	+= i2c-mux-gpio.o
 obj-$(CONFIG_I2C_MUX_PCA9541)	+= i2c-mux-pca9541.o
-obj-$(CONFIG_I2C_MUX_PCA954x)	+= i2c-mux-pca954x.o
+obj-$(CONFIG_I2C_MUX_PCA954x)	+= i2c-mux-pca9x4x.o
 obj-$(CONFIG_I2C_MUX_PINCTRL)	+= i2c-mux-pinctrl.o
 obj-$(CONFIG_I2C_MUX_REG)	+= i2c-mux-reg.o
 
diff --git a/drivers/i2c/muxes/i2c-mux-pca9541.c b/drivers/i2c/muxes/i2c-mux-pca9541.c
index d0ba424..dff3d03 100644
--- a/drivers/i2c/muxes/i2c-mux-pca9541.c
+++ b/drivers/i2c/muxes/i2c-mux-pca9541.c
@@ -24,7 +24,7 @@
 #include <linux/i2c.h>
 #include <linux/i2c-mux.h>
 
-#include <linux/i2c/pca954x.h>
+#include <linux/i2c/pca9x4x.h>
 
 /*
  * The PCA9541 is a bus master selector. It supports two I2C masters connected
@@ -323,7 +323,7 @@ static int pca9541_probe(struct i2c_client *client,
 			 const struct i2c_device_id *id)
 {
 	struct i2c_adapter *adap = client->adapter;
-	struct pca954x_platform_data *pdata = dev_get_platdata(&client->dev);
+	struct pca9x4x_platform_data *pdata = dev_get_platdata(&client->dev);
 	struct pca9541 *data;
 	int force;
 	int ret = -ENODEV;
diff --git a/drivers/i2c/muxes/i2c-mux-pca954x.c b/drivers/i2c/muxes/i2c-mux-pca954x.c
deleted file mode 100644
index acfcef3..0000000
--- a/drivers/i2c/muxes/i2c-mux-pca954x.c
+++ /dev/null
@@ -1,313 +0,0 @@
-/*
- * I2C multiplexer
- *
- * Copyright (c) 2008-2009 Rodolfo Giometti <giometti@linux.it>
- * Copyright (c) 2008-2009 Eurotech S.p.A. <info@eurotech.it>
- *
- * This module supports the PCA954x series of I2C multiplexer/switch chips
- * made by Philips Semiconductors.
- * This includes the:
- *	 PCA9540, PCA9542, PCA9543, PCA9544, PCA9545, PCA9546, PCA9547
- *	 and PCA9548.
- *
- * These chips are all controlled via the I2C bus itself, and all have a
- * single 8-bit register. The upstream "parent" bus fans out to two,
- * four, or eight downstream busses or channels; which of these
- * are selected is determined by the chip type and register contents. A
- * mux can select only one sub-bus at a time; a switch can select any
- * combination simultaneously.
- *
- * Based on:
- *	pca954x.c from Kumar Gala <galak@kernel.crashing.org>
- * Copyright (C) 2006
- *
- * Based on:
- *	pca954x.c from Ken Harrenstien
- * Copyright (C) 2004 Google, Inc. (Ken Harrenstien)
- *
- * Based on:
- *	i2c-virtual_cb.c from Brian Kuschak <bkuschak@yahoo.com>
- * and
- *	pca9540.c from Jean Delvare <jdelvare@suse.de>.
- *
- * This file is licensed under the terms of the GNU General Public
- * License version 2. This program is licensed "as is" without any
- * warranty of any kind, whether express or implied.
- */
-
-#include <linux/device.h>
-#include <linux/gpio/consumer.h>
-#include <linux/i2c.h>
-#include <linux/i2c-mux.h>
-#include <linux/i2c/pca954x.h>
-#include <linux/module.h>
-#include <linux/of.h>
-#include <linux/pm.h>
-#include <linux/slab.h>
-
-#define PCA954X_MAX_NCHANS 8
-
-enum pca_type {
-	pca_9540,
-	pca_9542,
-	pca_9543,
-	pca_9544,
-	pca_9545,
-	pca_9546,
-	pca_9547,
-	pca_9548,
-};
-
-struct pca954x {
-	enum pca_type type;
-	struct i2c_adapter *virt_adaps[PCA954X_MAX_NCHANS];
-
-	u8 last_chan;		/* last register value */
-};
-
-struct chip_desc {
-	u8 nchans;
-	u8 enable;	/* used for muxes only */
-	enum muxtype {
-		pca954x_ismux = 0,
-		pca954x_isswi
-	} muxtype;
-};
-
-/* Provide specs for the PCA954x types we know about */
-static const struct chip_desc chips[] = {
-	[pca_9540] = {
-		.nchans = 2,
-		.enable = 0x4,
-		.muxtype = pca954x_ismux,
-	},
-	[pca_9543] = {
-		.nchans = 2,
-		.muxtype = pca954x_isswi,
-	},
-	[pca_9544] = {
-		.nchans = 4,
-		.enable = 0x4,
-		.muxtype = pca954x_ismux,
-	},
-	[pca_9545] = {
-		.nchans = 4,
-		.muxtype = pca954x_isswi,
-	},
-	[pca_9547] = {
-		.nchans = 8,
-		.enable = 0x8,
-		.muxtype = pca954x_ismux,
-	},
-	[pca_9548] = {
-		.nchans = 8,
-		.muxtype = pca954x_isswi,
-	},
-};
-
-static const struct i2c_device_id pca954x_id[] = {
-	{ "pca9540", pca_9540 },
-	{ "pca9542", pca_9540 },
-	{ "pca9543", pca_9543 },
-	{ "pca9544", pca_9544 },
-	{ "pca9545", pca_9545 },
-	{ "pca9546", pca_9545 },
-	{ "pca9547", pca_9547 },
-	{ "pca9548", pca_9548 },
-	{ }
-};
-MODULE_DEVICE_TABLE(i2c, pca954x_id);
-
-/* Write to mux register. Don't use i2c_transfer()/i2c_smbus_xfer()
-   for this as they will try to lock adapter a second time */
-static int pca954x_reg_write(struct i2c_adapter *adap,
-			     struct i2c_client *client, u8 val)
-{
-	int ret = -ENODEV;
-
-	if (adap->algo->master_xfer) {
-		struct i2c_msg msg;
-		char buf[1];
-
-		msg.addr = client->addr;
-		msg.flags = 0;
-		msg.len = 1;
-		buf[0] = val;
-		msg.buf = buf;
-		ret = __i2c_transfer(adap, &msg, 1);
-	} else {
-		union i2c_smbus_data data;
-		ret = adap->algo->smbus_xfer(adap, client->addr,
-					     client->flags,
-					     I2C_SMBUS_WRITE,
-					     val, I2C_SMBUS_BYTE, &data);
-	}
-
-	return ret;
-}
-
-static int pca954x_select_chan(struct i2c_adapter *adap,
-			       void *client, u32 chan)
-{
-	struct pca954x *data = i2c_get_clientdata(client);
-	const struct chip_desc *chip = &chips[data->type];
-	u8 regval;
-	int ret = 0;
-
-	/* we make switches look like muxes, not sure how to be smarter */
-	if (chip->muxtype == pca954x_ismux)
-		regval = chan | chip->enable;
-	else
-		regval = 1 << chan;
-
-	/* Only select the channel if its different from the last channel */
-	if (data->last_chan != regval) {
-		ret = pca954x_reg_write(adap, client, regval);
-		data->last_chan = regval;
-	}
-
-	return ret;
-}
-
-static int pca954x_deselect_mux(struct i2c_adapter *adap,
-				void *client, u32 chan)
-{
-	struct pca954x *data = i2c_get_clientdata(client);
-
-	/* Deselect active channel */
-	data->last_chan = 0;
-	return pca954x_reg_write(adap, client, data->last_chan);
-}
-
-/*
- * I2C init/probing/exit functions
- */
-static int pca954x_probe(struct i2c_client *client,
-			 const struct i2c_device_id *id)
-{
-	struct i2c_adapter *adap = to_i2c_adapter(client->dev.parent);
-	struct pca954x_platform_data *pdata = dev_get_platdata(&client->dev);
-	struct device_node *of_node = client->dev.of_node;
-	bool idle_disconnect_dt;
-	struct gpio_desc *gpio;
-	int num, force, class;
-	struct pca954x *data;
-	int ret;
-
-	if (!i2c_check_functionality(adap, I2C_FUNC_SMBUS_BYTE))
-		return -ENODEV;
-
-	data = devm_kzalloc(&client->dev, sizeof(struct pca954x), GFP_KERNEL);
-	if (!data)
-		return -ENOMEM;
-
-	i2c_set_clientdata(client, data);
-
-	/* Get the mux out of reset if a reset GPIO is specified. */
-	gpio = devm_gpiod_get_optional(&client->dev, "reset", GPIOD_OUT_LOW);
-	if (IS_ERR(gpio))
-		return PTR_ERR(gpio);
-
-	/* Write the mux register at addr to verify
-	 * that the mux is in fact present. This also
-	 * initializes the mux to disconnected state.
-	 */
-	if (i2c_smbus_write_byte(client, 0) < 0) {
-		dev_warn(&client->dev, "probe failed\n");
-		return -ENODEV;
-	}
-
-	data->type = id->driver_data;
-	data->last_chan = 0;		   /* force the first selection */
-
-	idle_disconnect_dt = of_node &&
-		of_property_read_bool(of_node, "i2c-mux-idle-disconnect");
-
-	/* Now create an adapter for each channel */
-	for (num = 0; num < chips[data->type].nchans; num++) {
-		bool idle_disconnect_pd = false;
-
-		force = 0;			  /* dynamic adap number */
-		class = 0;			  /* no class by default */
-		if (pdata) {
-			if (num < pdata->num_modes) {
-				/* force static number */
-				force = pdata->modes[num].adap_id;
-				class = pdata->modes[num].class;
-			} else
-				/* discard unconfigured channels */
-				break;
-			idle_disconnect_pd = pdata->modes[num].deselect_on_exit;
-		}
-
-		data->virt_adaps[num] =
-			i2c_add_mux_adapter(adap, &client->dev, client,
-				force, num, class, pca954x_select_chan,
-				(idle_disconnect_pd || idle_disconnect_dt)
-					? pca954x_deselect_mux : NULL);
-
-		if (data->virt_adaps[num] == NULL) {
-			ret = -ENODEV;
-			dev_err(&client->dev,
-				"failed to register multiplexed adapter"
-				" %d as bus %d\n", num, force);
-			goto virt_reg_failed;
-		}
-	}
-
-	dev_info(&client->dev,
-		 "registered %d multiplexed busses for I2C %s %s\n",
-		 num, chips[data->type].muxtype == pca954x_ismux
-				? "mux" : "switch", client->name);
-
-	return 0;
-
-virt_reg_failed:
-	for (num--; num >= 0; num--)
-		i2c_del_mux_adapter(data->virt_adaps[num]);
-	return ret;
-}
-
-static int pca954x_remove(struct i2c_client *client)
-{
-	struct pca954x *data = i2c_get_clientdata(client);
-	const struct chip_desc *chip = &chips[data->type];
-	int i;
-
-	for (i = 0; i < chip->nchans; ++i)
-		if (data->virt_adaps[i]) {
-			i2c_del_mux_adapter(data->virt_adaps[i]);
-			data->virt_adaps[i] = NULL;
-		}
-
-	return 0;
-}
-
-#ifdef CONFIG_PM_SLEEP
-static int pca954x_resume(struct device *dev)
-{
-	struct i2c_client *client = to_i2c_client(dev);
-	struct pca954x *data = i2c_get_clientdata(client);
-
-	data->last_chan = 0;
-	return i2c_smbus_write_byte(client, 0);
-}
-#endif
-
-static SIMPLE_DEV_PM_OPS(pca954x_pm, NULL, pca954x_resume);
-
-static struct i2c_driver pca954x_driver = {
-	.driver		= {
-		.name	= "pca954x",
-		.pm	= &pca954x_pm,
-	},
-	.probe		= pca954x_probe,
-	.remove		= pca954x_remove,
-	.id_table	= pca954x_id,
-};
-
-module_i2c_driver(pca954x_driver);
-
-MODULE_AUTHOR("Rodolfo Giometti <giometti@linux.it>");
-MODULE_DESCRIPTION("PCA954x I2C mux/switch driver");
-MODULE_LICENSE("GPL v2");
diff --git a/drivers/i2c/muxes/i2c-mux-pca9x4x.c b/drivers/i2c/muxes/i2c-mux-pca9x4x.c
new file mode 100644
index 0000000..6892dde
--- /dev/null
+++ b/drivers/i2c/muxes/i2c-mux-pca9x4x.c
@@ -0,0 +1,479 @@
+/*
+ * I2C multiplexer
+ *
+ * Copyright (c) 2017 Adrian Fiergolski <Adrian.Fiergolski@cern.ch>
+ * Copyright (c) 2008-2009 Rodolfo Giometti <giometti@linux.it>
+ * Copyright (c) 2008-2009 Eurotech S.p.A. <info@eurotech.it>
+ *
+ * This module supports the PCA9x4x series of I2C multiplexer/switch chips
+ * made by Philips Semiconductors.
+ * This includes the:
+ *	 PCA9540, PCA9542, PCA9543, PCA9544, PCA9545, PCA9546, PCA9547
+ *	 and PCA9548.
+ *       PCA9846, PCA9847, PCA9848 and PCA9849
+ *
+ * These chips are all controlled via the I2C bus itself, and all have a
+ * single 8-bit register. The upstream "parent" bus fans out to two,
+ * four, or eight downstream busses or channels; which of these
+ * are selected is determined by the chip type and register contents. A
+ * mux can select only one sub-bus at a time; a switch can select any
+ * combination simultaneously.
+ *
+ * Based on:
+ *	pca954x.c from Kumar Gala <galak@kernel.crashing.org>
+ * Copyright (C) 2006
+ *
+ * Based on:
+ *	pca954x.c from Ken Harrenstien
+ * Copyright (C) 2004 Google, Inc. (Ken Harrenstien)
+ *
+ * Based on:
+ *	i2c-virtual_cb.c from Brian Kuschak <bkuschak@yahoo.com>
+ * and
+ *	pca9540.c from Jean Delvare <jdelvare@suse.de>.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/device.h>
+#include <linux/gpio/consumer.h>
+#include <linux/i2c.h>
+#include <linux/i2c-mux.h>
+#include <linux/i2c/pca9x4x.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/pm.h>
+#include <linux/slab.h>
+
+#define PCA9X4X_MAX_NCHANS 8
+
+//PCA984x family I2C other addresses
+#define GENERAL_CALL  0x00
+#define SOFTWARE_RESET 0x06
+#define DEVICE_ID_ADDRESS 0x7C
+#define NXP_ID 0x00
+
+enum pca_type {
+	pca_9540,
+	pca_9542,
+	pca_9543,
+	pca_9544,
+	pca_9545,
+	pca_9546,
+	pca_9547,
+	pca_9548,
+
+	pca_9846,
+	pca_9847,
+	pca_9848,
+	pca_9849,
+};
+
+struct pca9x4x {
+	enum pca_type type;
+	struct i2c_adapter *virt_adaps[PCA9X4X_MAX_NCHANS];
+
+	u8 last_chan;		/* last register value */
+};
+
+struct chip_desc {
+	u8 nchans;
+	u8 enable;	/* used for muxes only */
+	enum muxtype {
+		pca9x4x_ismux = 0,
+		pca9x4x_isswi
+	} muxtype;
+        u16 deviceID; // used by PCA984x family only
+};
+
+/* Provide specs for the PCA9x4x types we know about */
+static const struct chip_desc chips[] = {
+        //954x family
+        [pca_9540] = {
+		.nchans = 2,
+		.enable = 0x4,
+		.muxtype = pca9x4x_ismux,
+	},
+	[pca_9543] = {
+		.nchans = 2,
+		.muxtype = pca9x4x_isswi,
+	},
+	[pca_9544] = {
+		.nchans = 4,
+		.enable = 0x4,
+		.muxtype = pca9x4x_ismux,
+	},
+	[pca_9545] = {
+		.nchans = 4,
+		.muxtype = pca9x4x_isswi,
+	},
+	[pca_9547] = {
+		.nchans = 8,
+		.enable = 0x8,
+		.muxtype = pca9x4x_ismux,
+	},
+	[pca_9548] = {
+		.nchans = 8,
+		.muxtype = pca9x4x_isswi,
+	},
+
+	//984x family
+	[pca_9846] = {
+		.nchans = 4,
+		.muxtype = pca9x4x_isswi,
+		.deviceID = 0x10B,
+	},
+	
+	[pca_9847] = {
+		.nchans = 8,
+		.muxtype = pca9x4x_ismux,
+		.deviceID = 0x108,
+	},
+
+	[pca_9848] = {
+		.nchans = 8,
+		.muxtype = pca9x4x_isswi,
+		.deviceID = 0x10A,
+	},
+
+	[pca_9849] = {
+		.nchans = 4,
+		.muxtype = pca9x4x_ismux,
+		.deviceID = 0x109,
+	},
+
+
+
+};
+
+static const struct i2c_device_id pca9x4x_id[] = {
+        //954x family
+        { "pca9540", pca_9540 },
+	{ "pca9542", pca_9540 },
+	{ "pca9543", pca_9543 },
+	{ "pca9544", pca_9544 },
+	{ "pca9545", pca_9545 },
+	{ "pca9546", pca_9545 },
+	{ "pca9547", pca_9547 },
+	{ "pca9548", pca_9548 },
+
+	//984x family	
+	{ "pca9846", pca_9846 },
+	{ "pca9847", pca_9847 },
+	{ "pca9848", pca_9848 },
+	{ "pca9849", pca_9849 },
+
+	{ }
+};
+
+MODULE_DEVICE_TABLE(i2c, pca9x4x_id);
+
+
+/* Write to mux register. Don't use i2c_transfer()/i2c_smbus_xfer()
+   for this as they will try to lock adapter a second time */
+static int pca9x4x_reg_write(struct i2c_adapter *adap,
+			     struct i2c_client *client, u8 val)
+{
+	int ret = -ENODEV;
+
+	if (adap->algo->master_xfer) {
+		struct i2c_msg msg;
+		char buf[1];
+
+		msg.addr = client->addr;
+		msg.flags = 0;
+		msg.len = 1;
+		buf[0] = val;
+		msg.buf = buf;
+		ret = __i2c_transfer(adap, &msg, 1);
+	} else {
+		union i2c_smbus_data data;
+		ret = adap->algo->smbus_xfer(adap, client->addr,
+					     client->flags,
+					     I2C_SMBUS_WRITE,
+					     val, I2C_SMBUS_BYTE, &data);
+	}
+
+	return ret;
+}
+
+static int pca9x4x_select_chan(struct i2c_adapter *adap,
+			       void *client, u32 chan)
+{
+	struct pca9x4x *data = i2c_get_clientdata(client);
+	const struct chip_desc *chip = &chips[data->type];
+	u8 regval;
+	int ret = 0;
+
+	/* we make switches look like muxes, not sure how to be smarter */
+	if (chip->muxtype == pca9x4x_ismux)
+		regval = chan | chip->enable;
+	else
+		regval = 1 << chan;
+
+	/* Only select the channel if its different from the last channel */
+	if (data->last_chan != regval) {
+		ret = pca9x4x_reg_write(adap, client, regval);
+		data->last_chan = regval;
+	}
+
+	return ret;
+}
+
+static int pca9x4x_deselect_mux(struct i2c_adapter *adap,
+				void *client, u32 chan)
+{
+	struct pca9x4x *data = i2c_get_clientdata(client);
+
+	/* Deselect active channel */
+	data->last_chan = 0;
+	return pca9x4x_reg_write(adap, client, data->last_chan);
+}
+
+/*
+ * Part of probe function specific for pca954x family
+ */
+inline int pca954x_probe(struct i2c_client *client,
+			 const struct i2c_device_id *id){
+  struct pca9x4x *data =  i2c_get_clientdata(client);
+
+  /* Write the mux register at addr to verify
+   * that the mux is in fact present. This also
+   * initializes the mux to disconnected state.
+   */
+  if (i2c_smbus_write_byte(client, 0) < 0) {
+    return -ENODEV;
+  }
+
+  data->type = id->driver_data;
+
+  return 0;
+}
+
+/*
+ * Part of probe function specific for pca984x family
+ */
+inline int pca984x_probe(struct i2c_client *client,
+			 const struct i2c_device_id *id){
+
+  struct i2c_adapter *adap = to_i2c_adapter(client->dev.parent);
+  struct pca9x4x *data =  i2c_get_clientdata(client);
+  union i2c_smbus_data device_id_raw;  
+  u16 manufacturer_id; //12 bits
+  u16 device_id; //9 bits
+  u16 i; //iterator through chips table
+  
+  if ( !i2c_check_functionality(adap, I2C_FUNC_SMBUS_WRITE_BYTE_DATA) ){
+    dev_warn(&client->dev, "PCA9846 family: I2c adapter doesn't support I2C_FUNC_SMBUS_WRITE_BYTE_DATA");
+    return -ENODEV;
+  }
+
+  if ( !i2c_check_functionality(adap, I2C_FUNC_SMBUS_READ_I2C_BLOCK) ){
+    dev_warn(&client->dev, "PCA9846 family: I2c adapter doesn't support  I2C_FUNC_SMBUS_READ_I2C_BLOCK");
+    return -ENODEV;
+  }
+  
+  //
+  //Software reset
+  //
+  if ( i2c_smbus_xfer(client->adapter, GENERAL_CALL, client->flags,
+		      I2C_SMBUS_WRITE,  SOFTWARE_RESET, I2C_SMBUS_BYTE, NULL)  < 0 ) {
+    dev_warn(&client->dev, "PCA9846 family: Sofrware reset failed\n");
+    return -ENODEV;
+  }
+
+  //
+  //Get device ID
+  //
+  device_id_raw.block[0] = 3;  //read 3 bytes
+  if( i2c_smbus_xfer(client->adapter, DEVICE_ID_ADDRESS, client->flags,
+		     I2C_SMBUS_READ,  client->addr <<1,
+		     I2C_SMBUS_I2C_BLOCK_DATA, &device_id_raw ) ){
+    dev_warn(&client->dev, "PCA9846 family: Get device ID failed\n");
+    return -ENODEV;
+  }
+
+  //Device ID contains only 3 bytes
+  if( device_id_raw.block[0] != 3 ){
+    dev_warn(&client->dev, "PCA9846 family: Get device ID failed\n");
+    return -ENODEV;
+  }
+
+  //Check manufacturer ID (12 bits)
+  manufacturer_id = ( (u16) device_id_raw.block[1] << 4) | (device_id_raw.block[2] >> 4);
+  if( manufacturer_id != NXP_ID){
+    dev_warn(&client->dev, "PCA9846 family: Manufacturer ID does not match NXP\n");
+    return -ENODEV;
+  }
+
+  //Device ID (9 bits)
+  device_id = ( (u16) device_id_raw.block[2] << 5 ) | (device_id_raw.block[3] >> 3);
+  for(i = 0; i < sizeof(chips)/sizeof(chips[0]); i++){
+    if(device_id == chips[i].deviceID)
+      data -> type = i;
+  }
+  if(! data -> type) {
+    dev_warn(&client->dev, "PCA9846 family: DeviceID %x is not supported.\n", device_id );
+    return -ENODEV;
+  }
+    
+  //Check if it correponds to device tree
+  if(  id->driver_data != data -> type ){
+    dev_notice(&client->dev, "PCA9846 family: Actual device part ID %x does not match device tree description %x - continuing anyway.\n",
+	       data -> type,  id->driver_data);
+  }
+
+  return 0;
+}
+
+
+
+/*
+ * I2C init/probing/exit functions
+ */
+static int pca9x4x_probe(struct i2c_client *client,
+			 const struct i2c_device_id *id)
+{
+	struct i2c_adapter *adap = to_i2c_adapter(client->dev.parent);
+	struct pca9x4x_platform_data *pdata = dev_get_platdata(&client->dev);
+	struct device_node *of_node = client->dev.of_node;
+	bool idle_disconnect_dt;
+	struct gpio_desc *gpio;
+	int num, force, class;
+	struct pca9x4x *data;
+	int ret;
+
+	if (!i2c_check_functionality(adap, I2C_FUNC_SMBUS_BYTE))
+		return -ENODEV;
+
+	data = devm_kzalloc(&client->dev, sizeof(struct pca9x4x), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	i2c_set_clientdata(client, data);
+
+	/* Get the mux out of reset if a reset GPIO is specified. */
+	gpio = devm_gpiod_get_optional(&client->dev, "reset", GPIOD_OUT_LOW);
+	if (IS_ERR(gpio))
+		return PTR_ERR(gpio);
+
+
+        switch( id->driver_data ) {
+	case pca_9540 :
+	case pca_9542 :
+	case pca_9543 :
+	case pca_9544 :
+	case pca_9545 :
+	case pca_9546 :
+	case pca_9547 :
+	case pca_9548 :
+	  ret = pca954x_probe(client, id);
+	  break;
+	case pca_9846 :
+	case pca_9847 :
+	case pca_9848 :
+	case pca_9849 :
+	  ret = pca984x_probe(client, id);
+	  break;
+	}
+
+	if(ret < 0) {
+	  dev_warn(&client->dev, "probe failed\n");
+	  return -ENODEV;
+	}
+	
+	data->last_chan = 0;		   /* force the first selection */
+
+	idle_disconnect_dt = of_node &&
+		of_property_read_bool(of_node, "i2c-mux-idle-disconnect");
+
+	/* Now create an adapter for each channel */
+	for (num = 0; num < chips[data->type].nchans; num++) {
+		bool idle_disconnect_pd = false;
+
+		force = 0;			  /* dynamic adap number */
+		class = 0;			  /* no class by default */
+		if (pdata) {
+			if (num < pdata->num_modes) {
+				/* force static number */
+				force = pdata->modes[num].adap_id;
+				class = pdata->modes[num].class;
+			} else
+				/* discard unconfigured channels */
+				break;
+			idle_disconnect_pd = pdata->modes[num].deselect_on_exit;
+		}
+
+		data->virt_adaps[num] =
+			i2c_add_mux_adapter(adap, &client->dev, client,
+				force, num, class, pca9x4x_select_chan,
+				(idle_disconnect_pd || idle_disconnect_dt)
+					? pca9x4x_deselect_mux : NULL);
+
+		if (data->virt_adaps[num] == NULL) {
+			ret = -ENODEV;
+			dev_err(&client->dev,
+				"failed to register multiplexed adapter"
+				" %d as bus %d\n", num, force);
+			goto virt_reg_failed;
+		}
+	}
+
+	dev_info(&client->dev,
+		 "registered %d multiplexed busses for I2C %s %s\n",
+		 num, chips[data->type].muxtype == pca9x4x_ismux
+				? "mux" : "switch", client->name);
+
+	return 0;
+
+virt_reg_failed:
+	for (num--; num >= 0; num--)
+		i2c_del_mux_adapter(data->virt_adaps[num]);
+	return ret;
+}
+
+static int pca9x4x_remove(struct i2c_client *client)
+{
+	struct pca9x4x *data = i2c_get_clientdata(client);
+	const struct chip_desc *chip = &chips[data->type];
+	int i;
+
+	for (i = 0; i < chip->nchans; ++i)
+		if (data->virt_adaps[i]) {
+			i2c_del_mux_adapter(data->virt_adaps[i]);
+			data->virt_adaps[i] = NULL;
+		}
+
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int pca9x4x_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct pca9x4x *data = i2c_get_clientdata(client);
+
+	data->last_chan = 0;
+	return i2c_smbus_write_byte(client, 0);
+}
+#endif
+
+static SIMPLE_DEV_PM_OPS(pca9x4x_pm, NULL, pca9x4x_resume);
+
+static struct i2c_driver pca9x4x_driver = {
+	.driver		= {
+		.name	= "pca9x4x",
+		.pm	= &pca9x4x_pm,
+	},
+	.probe		= pca9x4x_probe,
+	.remove		= pca9x4x_remove,
+	.id_table	= pca9x4x_id,
+};
+
+module_i2c_driver(pca9x4x_driver);
+
+MODULE_AUTHOR("Rodolfo Giometti <giometti@linux.it>, Adrian Fiergolski <Adrian.Fiergolski@cern.ch>");
+MODULE_DESCRIPTION("PCA9x4x I2C mux/switch driver");
+MODULE_LICENSE("GPL v2");
diff --git a/include/linux/i2c/pca954x.h b/include/linux/i2c/pca9x4x.h
similarity index 82%
rename from include/linux/i2c/pca954x.h
rename to include/linux/i2c/pca9x4x.h
index 1712677..2aa3f94 100644
--- a/include/linux/i2c/pca954x.h
+++ b/include/linux/i2c/pca9x4x.h
@@ -2,6 +2,7 @@
  *
  * pca954x.h - I2C multiplexer/switch support
  *
+ * Copyright (c) 2017 Adrian Fiergolski <Adrian.Fiergolski@cern.ch>
  * Copyright (c) 2008-2009 Rodolfo Giometti <giometti@linux.it>
  * Copyright (c) 2008-2009 Eurotech S.p.A. <info@eurotech.it>
  * Michael Lawnick <michael.lawnick.ext@nsn.com>
@@ -22,10 +23,10 @@
  */
 
 
-#ifndef _LINUX_I2C_PCA954X_H
-#define _LINUX_I2C_PCA954X_H
+#ifndef _LINUX_I2C_PCA9X4X_H
+#define _LINUX_I2C_PCA9X4X_H
 
-/* Platform data for the PCA954x I2C multiplexers */
+/* Platform data for the PCA9X4x I2C multiplexers */
 
 /* Per channel initialisation data:
  * @adap_id: bus number for the adapter. 0 = don't care
@@ -33,15 +34,15 @@
  *                    of this channel after transaction.
  *
  */
-struct pca954x_platform_mode {
+struct pca9x4x_platform_mode {
 	int		adap_id;
 	unsigned int	deselect_on_exit:1;
 	unsigned int	class;
 };
 
 /* Per mux/switch data, used with i2c_register_board_info */
-struct pca954x_platform_data {
-	struct pca954x_platform_mode *modes;
+struct pca9x4x_platform_data {
+	struct pca9x4x_platform_mode *modes;
 	int num_modes;
 };
 
-- 
2.9.3

